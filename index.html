<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="css/main.css">
	</head>
	<body>

		<script type="module">


			//imports
			import * as THREE from './js/three.module.js';
			import { OrbitControls } from './js/OrbitControls.js';


			// helper objects
			let shadowCameraHelper, directionalLightHelper;


			// basic objects
			let camera, scene, renderer, controls;


			// world objects
			let towers, roofs, walls, ground, directionalLight, ambient;

			// load textures
			let texture_wall = new THREE.TextureLoader().load( 'textures/wall.jpg' );
			let texture_roof = new THREE.TextureLoader().load( 'textures/roof.jpg' );
			let texture_ground = new THREE.TextureLoader().load( 'textures/ground.jpg' );
			let texture_background = new THREE.TextureLoader().load( 'textures/universe.jpg' );


			// geometry and materials variables
			let geometry_tower = new THREE.CylinderBufferGeometry( 40, 40, 200, 200 );
			let material_wall = new THREE.MeshPhongMaterial( { map: texture_wall } );
			let geometry_roof = new THREE.ConeBufferGeometry( 50,50,32 );
			let material_roof = new THREE.MeshPhongMaterial( { map: texture_roof } );
			let geometry_wall_1 = new THREE.BoxBufferGeometry( 500, 100, 40 );
			let geometry_wall_2 = new THREE.BoxBufferGeometry( 40, 100, 500 );


			// basic functions call
			init();
			animate();
			render();


			// function to initiate the whole scene
			function init() {


				// create scene
				scene = new THREE.Scene();


				// setup renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );


				// enable shadows in renderer
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.outputEncoding = THREE.sRGBEncoding;


				//create ambient (basic light)
				ambient = new THREE.AmbientLight(0xffffff, 0.1);
				scene.add( ambient );


				// setup light
				directionalLight = new THREE.DirectionalLight( 0xffffff, 0.4 );
				directionalLight.position.set( -100, 90, 100 );
				directionalLight.castShadow = true;
				directionalLight.shadow.camera.near = 1;
				directionalLight.shadow.camera.far = 5000;
				let shadowCameraSize = 1000;
				directionalLight.shadow.camera.left = -shadowCameraSize;
				directionalLight.shadow.camera.right = shadowCameraSize;
				directionalLight.shadow.camera.top = shadowCameraSize;
				directionalLight.shadow.camera.bottom = -shadowCameraSize;
				scene.add( directionalLight );


				// setup helpers
				directionalLightHelper = new THREE.DirectionalLightHelper( directionalLight, 5 );
        //scene.add( directionalLightHelper ); DEBUG: not for prod
				shadowCameraHelper = new THREE.CameraHelper( directionalLight.shadow.camera );
				//scene.add(shadowCameraHelper); DEBUG: not for prod


				// setup camera
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 20;
				camera.position.y = 450;
				camera.position.x = -350;
				camera.lookAt(scene.position.set(-200, 0, 200));


				// setup OrbitControls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.keys = {
					LEFT: 37,
					UP: 38,
					RIGHT: 39,
					BOTTOM: 40
				};
				controls.keyPanSpeed = 15


				// setup background
				scene.background = texture_background;


				// setup texture to repeat (instead of cover)
				texture_wall.wrapS = THREE.RepeatWrapping;
				texture_wall.wrapT = THREE.RepeatWrapping;
				texture_wall.repeat.set(1, 0.5);


				//GROUND
				var geometry_ground = new THREE.PlaneBufferGeometry( 5000, 5000, 1 );
				geometry_ground.rotateX(-Math.PI * 0.5); // setup horizontally
				var ground_texture = new THREE.MeshPhongMaterial( { map: texture_ground, side: THREE.DoubleSide} );
				ground = new THREE.Mesh(geometry_ground, ground_texture);
				ground.receiveShadow = true;
				scene.add( ground );
				ground.position.y = -50;
				ground.position.x = 250;
				ground.position.z = -250;

				//TOWER
				towers = generate_towers();


				//ROOF
				roofs = generate_roofs();


				//WALL
				walls = generate_walls();


				// call resize on window changes
				window.addEventListener( 'resize', onWindowResize, false );
			}


			// resize camera when the window change resolution
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			// animation loop
			function animate() {

				requestAnimationFrame( animate );
				renderer.render( scene, camera );

			}


			// render : lmao idk why i wrote that
			function render() {

				shadowCameraHelper.update();
				directionalLightHelper.update();
				renderer.render( scene, camera );

			}


			// generate towers and return array of towers's object
			function generate_towers() {
				let array = [];
				let varX = 0;
				let varY = 0;
				let varZ = 0;

				for (var i = 1; i <= 4; i++) {
					if (i === 2) {
						varX = varX + 500;
					}
					if (i === 3) {
						varX = varX - 500;
						varZ = varZ - 500;
					}
					if (i === 4) {
						varX = varX + 500;
					}
					let tower = new THREE.Mesh( geometry_tower, material_wall );
					tower.castShadow = true;
					tower.receiveShadow = true;
					tower.position.x = varX;
					tower.position.y = varY;
					tower.position.z = varZ;
					array.push(tower);
					scene.add(tower);
				}
				return array;

			}


			// generate roofs and return array of roofs's object
			function generate_roofs() {
				let array = [];
				let varX = 0;
				let varY = 125;
				let varZ = 0;

				for (var i = 1; i <= 4; i++) {
					if (i === 2) {
						varX = varX + 500;
					}
					if (i === 3) {
						varX = varX - 500;
						varZ = varZ - 500;
					}
					if (i === 4) {
						varX = varX + 500;
					}
					let roof = new THREE.Mesh( geometry_roof, material_roof );
					roof.castShadow = true;
					roof.receiveShadow = true;
					roof.position.x = varX;
					roof.position.y = varY;
					roof.position.z = varZ;
					array.push(roof);
					scene.add(roof);
				}
				return array;

			}


			// generate walls and return array of walls's object
			function generate_walls() {
				let array = [];
				let varX = 250;
				let varY = 0;
				let varZ = 0;

				for (var i = 1; i <= 4; i++) {
					let wall;
					if (i === 1 || i === 4) {
						wall = new THREE.Mesh( geometry_wall_1, material_wall );
					} else {
						wall = new THREE.Mesh( geometry_wall_2, material_wall );
					}

					if (i === 2) {
						varX = varX - 250;
						varZ = varZ - 250;
					}
					if (i === 3) {
						varX = varX + 500;
					}
					if (i === 4) {
						varX = varX - 250;
						varZ = varZ - 250;
					}

					wall.castShadow = true;
					wall.receiveShadow = true;
					wall.position.x = varX;
					wall.position.y = varY;
					wall.position.z = varZ;
					array.push(wall);
					scene.add(wall);
				}
				return array;

			}

		</script>

	</body>
</html>
